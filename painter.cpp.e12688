#include "painter.h"



Scene::Scene(int x, int y, int w, int h)
{
    this->w = w;
    this->h = h;
    pool_tex = Texture(":/pool/pool.bmp");
    zbuf = new int[w * h];
    ibuf = Matrix(w*h, 3);
    ibuf_transparent = Matrix(w*h, 3);
    c_tr = new double[w*h];

    memset(zbuf, 0, sizeof(int) * w * h);
    memset(&ibuf[0][0], 0, 3 * w * h * sizeof(double));
    memset(&ibuf_transparent[0][0], 0, 3 * w * h * sizeof(double));
    memset(c_tr, 0, sizeof(double) * w * h);

    scene = new QGraphicsScene();
    scene->setSceneRect(x, y, w, h);

    img = new ImageItem(w, h);
    setViewPort(x, y, w, h);

    model = Model(70, 70);
    pool_model = PoolModel(model.surf[model.zvert+1][0],
            model.surf[model.xvert*(model.zvert-1)-1][0],
            model.surf[1][2],
            model.surf[model.zvert-2][2]);

    cam.eye[0] = -0.8;
    cam.eye[1] = -0.9;
    cam.eye[2] = 0.9;

    setviewmatr();
    setprojmatr();

    light_dir = Vector(3);
    light_dir[0] = -.9;
    light_dir[1] = -.9;
    light_dir[2] = .9;
    normalize(light_dir);

    scene->addItem(img);



}

Scene::~Scene()
{
    delete img;
    delete scene;
    delete c_tr;
    delete zbuf;
}

void Scene::setViewPort(int x, int y, int w, int h)
{
    viewPort = Matrix(4, 4);
    identity4(viewPort);
    viewPort[0][3] = x+w/2.f;
    viewPort[1][3] = y+h/2.f;

    viewPort[2][3] = 8000000/2.f;

    viewPort[0][0] = w/2.f;
    viewPort[1][1] = h/2.f;
    viewPort[2][2] = 8000000/2.f;
}

void Scene::setviewmatr()
{
    cam.center[0] = 0;
    cam.center[1] = 0;
    cam.center[2] = 0;
    cam.up[0] = 0;
    cam.up[1] = 1;
    cam.up[2] = 0;

    Vector z(3);
    Vector x(3);
    Vector y(3);

    z = cam.eye - cam.center;
    normalize(z);
    x = cross(cam.up,z);
    normalize(x);
    y = cross(z,x);
    normalize(y);

    Matrix Minv(4, 4);
    Matrix Tr(4, 4);
    identity4(Minv);
    identity4(Tr);
    for (int i = 0; i < 3; i++)
    {
        Minv[0][i] = x[i];
        Minv[1][i] = y[i];
        Minv[2][i] = z[i];
        Tr[i][3] = -cam.center[i];
    }
    viewMatr = Minv * Tr;
}

void Scene::setprojmatr()
{
    projMatr = Matrix(4, 4);
    identity4(projMatr);
    projMatr[3][2] = -1.0 /
            sqrt((cam.eye[0]) * (cam.eye[0]) + (cam.eye[1]) * (cam.eye[1]) + (cam.eye[2]) * (cam.eye[2]));

}

void Scene::drawimage()
{
    Matrix m = viewPort * projMatr * viewMatr;
    model.setscreensurf(m);
    pool_model.setscreensurf(m);
    pool_model.setnormals();
    int xv = model.xvert;
    int zv = model.zvert;

    double t = model.transparent;
    double u1[] = {0.05, 0.95, 0.95};
    double v1[] = {0.05, 0.05, 0.95};
    double u2[] = {0.05, 0.05, 0.95};
    double v2[] = {0.05, 0.95, 0.95};

        // Стенки бассейна - рисуются, если изменилось положение камеры
    if (changed)
    {
        changed = false;
        memset(zbuf, 0, sizeof(int) * w * h);
        memset(&ibuf[0][0], 0, 3 * w * h * sizeof(double));
        #pragma omp parallel for
        for (int i = 0; i < 3; ++i)
        {
            if (pool_model.surf_deform_norms[2*i][2] > 0)
            {
                triangle(V(pool_model.surf_screen[i]), V(pool_model.surf_screen[i+4]), V(pool_model.surf_screen[i+4+1]),
                        V(pool_model.i[i]), u1, v1);
                triangle(V(pool_model.surf_screen[i]), V(pool_model.surf_screen[i+1]), V(pool_model.surf_screen[i+4+1]),
                        V(pool_model.i[i]), u2, v2);
            }
        }
        if (pool_model.surf_deform_norms[6][2] > 0)
        {
        triangle(V(pool_model.surf_screen[3]), V(pool_model.surf_screen[7]), V(pool_model.surf_screen[4]),
                V(pool_model.i[3]), u1, v1);
        triangle(V(pool_model.surf_screen[3]), V(pool_model.surf_screen[0]), V(pool_model.surf_screen[4]),
                V(pool_model.i[3]), u2, v2);
        }

        triangle(V(pool_model.surf_screen[4]), V(pool_model.surf_screen[5]), V(pool_model.surf_screen[6]),
                V(pool_model.i[4]), u1, v1);
        triangle(V(pool_model.surf_screen[4]), V(pool_model.surf_screen[7]), V(pool_model.surf_screen[6]),
                V(pool_model.i[4]), u2, v2);
    }

     // Поверхность воды
    #pragma omp parallel for
    for (int i = 1; i < xv-2; ++i)
    {
        for (int j = 1; j < zv-2; ++j)
        {
            int k = i*xv+j;
            triangle(V(model.surf_screen[k]), V(model.surf_screen[k+xv]), V(model.surf_screen[k+xv+1]),
                    V(model.i[k]), V(model.i[k+xv]), V(model.i[k+xv+1]), t);
            triangle(V(model.surf_screen[k]), V(model.surf_screen[k+1]), V(model.surf_screen[k+xv+1]),
                    V(model.i[k]), V(model.i[k+1]), V(model.i[k+xv+1]), t);
        }
    }


    int n = xv*xv;
        //Левая стенка воды
    if (pool_model.surf_deform_norms[6][2] <= 0)
    {
        #pragma omp parallel for
        for(int l = 1; l < xv - 2; l++)
        {
            triangle(V(model.surf_screen[l + xv]), V(model.surf_screen[l + n - 1]), V(model.surf_screen[l + n]),
                    model.i_wall, model.i_wall, model.i_wall, t);
            triangle(V(model.surf_screen[l + xv]), V(model.surf_screen[l+xv+1]), V(model.surf_screen[l+n]),
                    model.i_wall, model.i_wall, model.i_wall, t);
        }
    }
        //Задняя стенка воды
    if (pool_model.surf_deform_norms[4][2] <= 0)
    {
        #pragma omp parallel for
        for(int l = 1; l < xv-2; l++)
        {
            triangle(V(model.surf_screen[xv*l+1]), V(model.surf_screen[n + xv + l - 3]), V(model.surf_screen[n + xv + l - 2]),
                    model.i_wall, model.i_wall, model.i_wall, t);
            triangle(V(model.surf_screen[xv*l+1]), V(model.surf_screen[xv * l + 1 + xv]), V(model.surf_screen[n + xv + l - 2]),
                    model.i_wall, model.i_wall, model.i_wall, t);
        }
    }
        //Правая стенка воды
    if (pool_model.surf_deform_norms[2][2] <= 0)
    {
        #pragma omp parallel for
        for(int l = 1; l < xv-2; l++)
        {
            triangle(V(model.surf_screen[n-2*xv+l]), V(model.surf_screen[n+2*xv+l-5]), V(model.surf_screen[n+2*xv+l-4]),
                    model.i_wall, model.i_wall, model.i_wall, t);
            triangle(V(model.surf_screen[n-2*xv+l]), V(model.surf_screen[n-2*xv+l+1]), V(model.surf_screen[n+2*xv+l-4]),
                    model.i_wall, model.i_wall, model.i_wall, t);
        }
    }
         //Передняя стенка воды
    if (pool_model.surf_deform_norms[0][2] <= 0)
    {
        #pragma omp parallel for
        for(int l = 1; l < xv-2; l++)
        {
            triangle(V(model.surf_screen[xv-2+xv*l]), V(model.surf_screen[n+3*xv+l-7]), V(model.surf_screen[n+3*xv+l-6]),
                    model.i_wall, model.i_wall, model.i_wall, t);
            triangle(V(model.surf_screen[xv-2+xv*l]), V(model.surf_screen[2*xv-2+xv*l]), V(model.surf_screen[n+3*xv+l-6]),
                    model.i_wall, model.i_wall, model.i_wall, t);
        }
    }

        // Объединение буферов и вывод на изображение
    #pragma omp parallel for
    for (int i = 0; i < h; i++)
        for (int j = 0; j < w; j++)
        {
            int k = i*w + j;
            if (c_tr[k] != 0 || zbuf[k] != 0)
                img->set(j, i, ibuf_transparent[k][0] + (1 - c_tr[k]) * ibuf[k][0]+5,
                        ibuf_transparent[k][1] + (1 - c_tr[k]) * ibuf[k][2]+5,
                        ibuf_transparent[k][1] + (1 - c_tr[k]) * ibuf[k][2]+5);
        }
    memset(&ibuf_transparent[0][0], 0, 3 * w * h * sizeof(double));
    memset(c_tr, 0, sizeof(double) * w * h);
}

void Scene::updheights()
{
    model.updheights();
}

void Scene::rand_disturb()
{
    int k = rand() % (model.xvert * model.zvert - model.xvert);
    if ((k+1) % model.zvert == 0)
        k--;

    model.H1[k] += .1;
    model.H2[k] += .1;

    model.H1[k + 1] += .1;
    model.H2[k + 1] += .1;

    model.H1[k + model.xvert] += .1;
    model.H2[k + model.xvert] += .1;

    model.H1[k + model.xvert + 1] += .1;
    model.H2[k + model.xvert + 1] += .1;
}

void Scene::calc_normals()
{
    model.calc_normals();
    pool_model.calc_normals();

}

void Scene::calc_intencities()
{
    Vector v = norm(cam.eye);
    Vector h = norm(v + light_dir);

    int xvert = model.xvert;
    int zvert = model.zvert;

    #pragma omp parallel for
    for (int i = 1; i < xvert-1; ++i)
    {
        for (int j = 1; j < zvert-1; ++j)
        {
            int k = i * xvert + j;
            // Фоновое освещение
            model.i[k] = model.color * 0.1;
            // Диффузное освещение (по Ламберту)
            model.i[k] += 0.2 * model.color * std::max(dot(light_dir, norm(V(model.vert_norms[k]))), 0.0);
            // Зеркальное освещение (по Блинну-Фонгу)
            model.i[k] += 0.7 * model.light_color * pow(std::max(0.0, dot(h, norm(V(model.vert_norms[k])))), 20);
        }
    }

    xvert = pool_model.xvert;
    zvert = pool_model.zvert;
    #pragma omp parallel for
    for (int i = 0; i < 5; ++i)
    {
            // Фоновое освещение
            pool_model.i[i] = pool_model.color * 0.6;
            // Диффузное освещение (по Ламберту)
            //pool_model.i[i] += 0.9 * pool_model.color * std::max(dot(light_dir, norm(V(pool_model.surf_norms[2*i]))), 0.0);
    }
}

void Scene::set_changed()
{
    changed = true;
}

void Scene::triangle(Vector a, Vector b, Vector c, Vector i_, const double *ut, const double *vt)
{
    i_ = i_ / 255.0;

    double u[] = {ut[0], ut[1], ut[2]};
    double v[] = {vt[0], vt[1], vt[2]};

    if (b[1] < a[1]) {
        dswap(&(u[0]), &(u[1]));
        dswap(&(v[0]), &(v[1]));
        a.swap(b);
    }
    if (c[1] < a[1]) {

        dswap(&(u[0]), &(u[2]));
        dswap(&(v[0]), &(v[2]));
        a.swap(c);
    }
    if (b[1] > c[1]) {
        dswap(&(u[1]), &(u[2]));
        dswap(&(v[1]), &(v[2]));
        b.swap(c);
    }
    if (int(a[1]+.5) == int(b[1]+.5) && b[0] < a[0])
    {
        dswap(&(u[0]), &(u[1]));
        dswap(&(v[0]), &(v[1]));
        a.swap(b);
    }

    int x1 = int(a[0] + .5);
    int x2 = int(b[0] + .5);
    int x3 = int(c[0] + .5);
    int y1 = int(a[1] + .5);
    int y2 = int(b[1] + .5);
    int y3 = int(c[1] + .5);
    int z1 = int(a[2] + .5);
    int z2 = int(b[2] + .5);
    int z3 = int(c[2] + .5);

    double dx13 = 0, dx12 = 0, dx23 = 0;
    double dz13 = 0, dz12 = 0, dz23 = 0;
    double du13 = 0, du12 = 0, du23 = 0;
    double dv13 = 0, dv12 = 0, dv23 = 0;

    if (y3 != y1)
    {
        dz13 = (z3 - z1) / (double)(y3 - y1);
        dx13 = (x3 - x1) / (double)(y3 - y1);
        du13 = (u[2] - u[0]) / (double)(y3 - y1);
        dv13 = (v[2] - v[0]) / (double)(y3 - y1);
    }
    if (y2 != y1)
    {
        dz12 = (z2 - z1) / (double)(y2 - y1);
        dx12 = (x2 - x1) / (double)(y2 - y1);
        du12 = (u[1] - u[0]) / (double)(y2 - y1);
        dv12 = (v[1] - v[0]) / (double)(y2 - y1);
    }
    if (y3 != y2)
    {
        dz23 = (z3 - z2) / (double)(y3 - y2);
        dx23 = (x3 - x2) / (double)(y3 - y2);
        du23 = (u[2] - u[1]) / (double)(y3 - y2);
        dv23 = (v[2] - v[1]) / (double)(y3 - y2);
    }

    double z;
    double dz;
    double u_;
    double v_;
    double du;
    double dv;

    double wx1 = x1;
    double wx2 = wx1;
    double wz1 = z1;
    double wz2 = z1;

    double wu1 = u[0];
    double wu2 = wu1;
    double wv1 = v[0];
    double wv2 = v[0];


    double _dx13 = dx13;
    double _dz13 = dz13;
    double _du13 = du13;
    double _dv13 = dv13;
    if (dx13 > dx12)
    {
        swap_(&dz13, &dz12);
        swap_(&dx13, &dx12);
        swap_(&du13, &du12);
        swap_(&dv13, &dv12);
    }
    for (int i = y1; i < y2; i++)
    {
        z = wz1;
        u_ = wu1;
        v_ = wv1;

        if (wx1 != wx2)
        {
            du = (wu2 - wu1) / (wx2 - wx1);
            dv = (wv2 - wv1) / (wx2 - wx1);
            dz = (wz2 - wz1) / (wx2 - wx1);
        }
        for (int j = wx1; j < wx2; j++)
        {
            int idx = i * h + j;

            if (zbuf[idx] < z)
            {
                QRgb i = pool_tex.texel(u_, v_);

                ibuf[idx][0] = qRed(i) * i_[0];
                ibuf[idx][1] = qGreen(i) * i_[1];
                ibuf[idx][2] = qBlue(i) * i_[2];
                zbuf[idx] = z;
            }
            z += dz;
            u_ += du;
            v_ += dv;
        }
        wx1 += dx13;
        wx2 += dx12;
        wz1 += dz13;
        wz2 += dz12;
        wu1 += du13;
        wu2 += du12;
        wv1 += dv13;
        wv2 += dv12;
    }

    if (y1 == y2){
        wx1 = x1;
        wx2 = x2;
        wz1 = z1;
        wz2 = z2;
        wu1 = u[0];
        wu2 = u[1];
        wv1 = v[0];
        wv2 = v[1];
    }
    if (_dx13 < dx23)
    {
        swap_(&_dx13, &dx23);
        swap_(&_dz13, &dz23);
        swap_(&_du13, &du23);
        swap_(&_dv13, &dv23);
    }
    for (int i = y2; i <= y3; i++){
        z = wz1;
        u_ = wu1;
        v_ = wv1;
        if (wx1 != wx2)
        {
            du = (wu2 - wu1) / (wx2 - wx1);
            dv = (wv2 - wv1) / (wx2 - wx1);
            dz = (wz2 - wz1) / (wx2 - wx1);
        }
        for (int j = wx1; j < wx2; j++)
        {
            int idx = i * h + j;
           if (zbuf[idx] < z)
            {
               QRgb i = pool_tex.texel(u_, v_);
               ibuf[idx][0] = qRed(i) * i_[0];
               ibuf[idx][1] = qGreen(i) * i_[1];
               ibuf[idx][2] = qBlue(i) * i_[2];
               zbuf[idx] = z;
            }
            z += dz;
            u_ += du;
            v_ += dv;
        }
        wx1 += _dx13;
        wx2 += dx23;
        wz1 += _dz13;
        wz2 += dz23;
        wu1 += _du13;
        wu2 += du23;
        wv1 += _dv13;
        wv2 += dv23;
    }
}


void Scene::triangle(Vector a, Vector b, Vector c, Vector ia, Vector ib, Vector ic, double c_)
{
    if (b[1] < a[1]) {
        a.swap(b);
        ia.swap(ib);
    }
    if (c[1] < a[1]) {
        a.swap(c);
        ia.swap(ic);
    }
    if (b[1] > c[1]) {
        b.swap(c);
        ib.swap(ic);
    }
    if (int(a[1]+.5) == int(b[1]+.5) && b[0] < a[0])
    {
        a.swap(b);
        ia.swap(ib);
    }

    int x1 = int(a[0] + .5);
    int x2 = int(b[0] + .5);
    int x3 = int(c[0] + .5);
    int y1 = int(a[1] + .5);
    int y2 = int(b[1] + .5);
    int y3 = int(c[1] + .5);
    int z1 = int(a[2] + .5);
    int z2 = int(b[2] + .5);
    int z3 = int(c[2] + .5);

    double dx13 = 0, dx12 = 0, dx23 = 0;
    double dz13 = 0, dz12 = 0, dz23 = 0;
    Vector di13(3);
    Vector di12(3);
    Vector di23(3);


    if (y3 != y1)
    {
        dz13 = (z3 - z1) / (double)(y3 - y1);
        dx13 = (x3 - x1) / (double)(y3 - y1);
        di13 = (ic - ia) / (double)(y3 - y1);
    }
    else
    {
        dx13 = 0;
        dz13 = 0;
        di13 = 0;
    }
    if (y2 != y1)
    {
        dz12 = (z2 - z1) / (double)(y2 - y1);
        dx12 = (x2 - x1) / (double)(y2 - y1);
        di12 = (ib - ia) / (double)(y2 - y1);
    }
    else
    {
        dz12 = 0;
        dx12 = 0;
        di12 = 0;
    }
    if (y3 != y2)
    {
        dz23 = (z3 - z2) / (double)(y3 - y2);
        dx23 = (x3 - x2) / (double)(y3 - y2);
        di23 = (ic - ib) / (double)(y3 - y2);
    }
    else
    {
        dz23 = 0;
        dx23 = 0;
        di23 = 0;
    }
    double z;
    double dz;

    Vector iv(3);
    Vector di(3);

    double wx1 = x1;
    double wx2 = wx1;
    double wz1 = z1;
    double wz2 = z1;
    Vector wi1(ia);
    Vector wi2(ia);

    Vector _di13(di13);
    double _dx13 = dx13;
    double _dz13 = dz13;

    if (dx13 > dx12)
    {
        swap_(&dz13, &dz12);
        swap_(&dx13, &dx12);
        di13.swap(di12);
    }
    for (int i = y1; i < y2; i++)
    {
        z = wz1;
        iv = wi1;

        if (wx1 != wx2)
        {
            dz = (wz2 - wz1) / (double)(wx2 - wx1);
            di = (wi2 - wi1) / (double)(wx2 - wx1);
        }
        else
        {
            dz = 0;
            di = 0;
        }
        for (int j = wx1; j < wx2; j++)
        {
            int idx = i * h + j;

            if (zbuf[idx] < z)
            {
                if (iv[2] > ibuf_transparent[idx][2])
                {
                    c_tr[idx] = c_;
                    ibuf_transparent[idx] = c_ * iv;
                }
            }
            z += dz;
            iv += di;
        }
        wx1 += dx13;
        wx2 += dx12;
        wz1 += dz13;
        wz2 += dz12;
        wi1 += di13;
        wi2 += di12;
    }

    if (y1 == y2){
        wx1 = x1;
        wx2 = x2;
        wz1 = z1;
        wz2 = z2;
        wi1 = ia;
        wi2 = ib;
    }
    if (_dx13 < dx23)
    {
        swap_(&_dx13, &dx23);
        swap_(&_dz13, &dz23);
        _di13.swap(di23);
    }
    for (int i = y2; i < y3; i++){
        z = wz1;
        iv = wi1;

        if (wx1 != wx2)
        {
            dz = (wz2 - wz1) / (double)(wx2 - wx1);
            di = (wi2 - wi1) / (double)(wx2 - wx1);
        }
        else
        {
            dz = 0;
            di = 0;
        }

        for (int j = wx1; j < wx2; j++)
        {
            int idx = i * h + j;
           if (zbuf[idx] < z)
            {
               if (iv[2] > ibuf_transparent[idx][2])
               {
                   c_tr[idx] = c_;
                   ibuf_transparent[idx] = c_ * iv;
               }
            }
            z += dz;
            iv += di;
        }
        wx1 += _dx13;
        wx2 += dx23;
        wz1 += _dz13;
        wz2 += dz23;
        wi1 += _di13;
        wi2 += di23;
    }
}

